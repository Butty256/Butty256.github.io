<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bit on Butty Blog</title>
    <link>https://butty256.github.io/tags/bit/</link>
    <description>Recent content in bit on Butty Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Thu, 31 Dec 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://butty256.github.io/tags/bit/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>bit を高速に数える 手法の比較</title>
      <link>https://butty256.github.io/posts/c/popcnt/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://butty256.github.io/posts/c/popcnt/</guid>
      <description>この記事は Qiita に投稿した内容です。
はじめに 本記事では bit の 1 の数を数える手法（アルゴリズム）の比較を行います。アルゴリズムの詳しい内容等は紹介せずあくまで処理速度の比較だけ行います。アルゴリズムの詳しい内容は下の参考文献に飛んでください。
アルゴリズム Hamming weight で紹介されている 5 つの手法の演算回数について簡単にまとめます。A は有名なアルゴリズムをそのまま実装した状態です。Bと C は A の高速化である派生です。D は bit が立っている（1 になっている）数に比例して演算量が増えます。E は力技で，16bit すべての数に対して立ってる bit の数をメモしておき，64bit を 4 分割してその合計として求めています。メモリを多く使用し，64bit のように bit 数が多い場合はあまり高速ではありません。
   手法 算術 乗算 比較 / 分岐 メモリ読み込み 特徴     A 24 0 0 0 単純な実装   B 17 0 0 0 乗算が遅い環境で優秀   C 12 1 0 0 乗算が速い環境で優秀   D 3n 0 1n 0 n は 1 になっている数，n が小さいと高速   E 9 0 0 4 16bit ごとに分けてメモリから読み取る    実験 実験環境・ソースコード 実験で使用したソースコードは GitHub にあげておきます。実験環境は下のとおりです。最適化については GitHub にあげている Makefile を見てください。</description>
    </item>
    
  </channel>
</rss>